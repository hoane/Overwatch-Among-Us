import "main.ostw";

enum PlayerRole {
    CREW,
    IMPOSTER
}

globalvar Vector circleCenter = Vector(-208.7, 0.0, -16.4);
globalvar Corpse[] corpses = EmptyArray();

// Player Variables
playervar PlayerRole role;
playervar define isAlive = true;
playervar define hudInteractString = "";
playervar define hudReloadString = "";
playervar Task[] incompleteTasks;
playervar Task[] completeTasks = EmptyArray();
playervar Corpse closestCorpse;
playervar define canReportCorpse = false;
playervar define originalHero;

/* Initial setup for players.
 * Disables most abilities and ui elements.
 */
rule: "Player Setup"
Event.OnPlayerJoin
{
    DisableGameModeHud(EventPlayer());
    DisableKillFeed(EventPlayer());
    DisableMessages(EventPlayer());
    DisableSpectate(EventPlayer());
    DisableHeroHud(EventPlayer())
    DisableSpectateHUD(EventPlayer());
    DisableNameplates(EventPlayer());
    DisableRespawning(EventPlayer());
    DisableScoreboard(EventPlayer());
    SetUltimateAbilityEnabled(EventPlayer(), false);
    SetMeleeEnabled(EventPlayer(), false);
    SetCrouchEnabled(EventPlayer(), false);
    SetReloadEnabled(EventPlayer(), false);
    SetAbility1Enabled(EventPlayer(), false);
    SetAbility2Enabled(EventPlayer(), false);
    SetPrimaryFireEnabled(EventPlayer(), false);
    SetSecondaryFireEnabled(EventPlayer(), false);
    SetJumpEnabled(EventPlayer(), false);
    SetDamageReceived(EventPlayer(), 0);
}

define respawnLocation: Vector(-199.46, 1.01, -7.59);

rule: "Player: On Death"
Event.OnDeath
{
    Wait(10);
    Resurrect(EventPlayer());
    Teleport(EventPlayer(), respawnLocation);
}

/* Puts an orb in the center of the map.
 */
void markCenter() {
    CreateEffect(AllPlayers(), Effect.Sphere, Color.Aqua, circleCenter, 1, EffectRev.None);
}

/* Calculates a position on the edge of a circle based on its center, radius, and the target 'slot' of the circle.
 */
Vector circlePosition(Vector center, ref define slot, ref define totalSlots, define radius) {
    define radians = (2 * Pi() * slot) / totalSlots;
    return Vector(XOf(center) + (radius * CosineFromRadians(radians)), YOf(center), ZOf(center) + (radius * SineFromRadians(radians)));
}

/* Place a player in the starting circle.
 */
void putPlayerInCircle(ref define player) {
    define pos = circlePosition(circleCenter, SlotOf(player), 10, 8.0)
    Teleport(AllPlayers()[SlotOf(player)], pos);
    SetFacing(AllPlayers()[SlotOf(player)], circleCenter - pos);
}

/* Set player status roles randomly per the imposter count.
 */
void assignRoles(ref define imposters) {
    AllPlayers().role = PlayerRole.CREW;
    ChooseArray(AllPlayers(), imposters).role = PlayerRole.IMPOSTER;
}

/* Give each player a selection of random tasks.
 * Tasks only contribute to the total task target if the player is Crew.
 */
void assignTasks(ref define player, ref define numTasks) {
    player.numTasks = numTasks;
    player.incompleteTasks = ChooseArray(global_tasks, numTasks);
    if (player.role == PlayerRole.CREW) {
        totalTaskCount += numTasks;
    }
}

/* Update the hud task strings.
 */
void updateHudStrings(ref define player) {
    player.hudTaskString = <"TODO:<0><1><2><3><4><5>",
        player.incompleteTasks.Length > 0 ? <"\n▷ <0>", player.incompleteTasks[0].Name> : "",
        player.incompleteTasks.Length > 1 ? <"\n▷ <0>", player.incompleteTasks[1].Name> : "",
        player.incompleteTasks.Length > 2 ? <"\n▷ <0>", player.incompleteTasks[2].Name> : "",
        player.incompleteTasks.Length > 3 ? <"\n▷ <0>", player.incompleteTasks[3].Name> : "",
        player.incompleteTasks.Length > 4 ? <"\n▷ <0>", player.incompleteTasks[4].Name> : "",
        player.incompleteTasks.Length > 5 ? <"\n▷ <0>", player.incompleteTasks[5].Name> : ""
    >;
    player.hudCompleteTaskString = <"Done:<0><1><2><3><4><5>",
        player.completeTasks.Length > 0 ? <"\n▶ <0>", player.completeTasks[0].Name> : "",
        player.completeTasks.Length > 1 ? <"\n▶ <0>", player.completeTasks[1].Name> : "",
        player.completeTasks.Length > 2 ? <"\n▶ <0>", player.completeTasks[2].Name> : "",
        player.completeTasks.Length > 3 ? <"\n▶ <0>", player.completeTasks[3].Name> : "",
        player.completeTasks.Length > 4 ? <"\n▶ <0>", player.completeTasks[4].Name> : "",
        player.completeTasks.Length > 5 ? <"\n▶ <0>", player.completeTasks[5].Name> : ""
    >;
}

/* Debug-only update logic.
 */
void debugUpdate(ref define player) {
    if (IsButtonHeld(player, Button.Ultimate)) {
        totalCompleteTaskCount += 5;
        checkEndGame();
    }
    if (IsButtonHeld(player, Button.Ability1)) {
        killPlayer(RandomValueInArray(AllAlive()));
    }
}

/* Find the nearest task to the crew member.
 */
void findCrewNearestTask(ref define player) {
    player.hudInteractString = "";
    // Find first incomplete task within 3 meters
    for (define i=0; i < player.incompleteTasks.Length; i++) {
        if (DistanceBetween(PositionOf(player), player.incompleteTasks[i].Position) <= 3) {
            player.hudInteractString = player.incompleteTasks[i].Name;
            player.interactableTask = player.incompleteTasks[i];
            player.canTask = true;

            if (IsButtonHeld(player, Button.Interact)) {
                return;
            }
        }
    }
}


/* Find the nearest corpse and check if it is near enough to be reportable.
 */
void findNearestCorpse(ref define player) {
    define closestCorpseDistance = 10.0;
    define _closestCorpse;
    foreach (Corpse corpse in corpses) {
        define distance = DistanceBetween(PositionOf(player), corpse.Position);
        if (distance <= closestCorpseDistance) {
            _closestCorpse = corpse;
            closestCorpseDistance = distance;
        }
    }

    if (closestCorpseDistance <= 5.0) {
        player.closestCorpse = _closestCorpse;
        player.canReportCorpse = true;
        player.hudReloadString = "Report";
    } else {
        player.hudReloadString = "";
    }
}

/* Per-tick state update for all players, crew and imposters
 */
void playerUpdate(ref define player) {
    findNearestCorpse(player);
    debugUpdate(player);
}

rule: "Player: isAlive"
Event.OngoingPlayer
if (gameState == GameState.Play || gameState == GameState.Voting)
if (playing)
if (EventPlayer().isAlive)
{
    EnableMovementCollisionWithPlayers(EventPlayer());
    SetInvisible(EventPlayer(), InvisibleTo.None);
    SetMoveSpeed(EventPlayer(), 100);
}

rule: "Player: !isAlive"
Event.OngoingPlayer
if (gameState == GameState.Play || gameState == GameState.Voting)
if (playing)
if (!EventPlayer().isAlive)
{
    EventPlayer().originalHero = HeroOf(EventPlayer());
    DisableMovementCollisionWithPlayers(EventPlayer());
    SetInvisible(EventPlayer(), InvisibleTo.All);
    ForcePlayerHero(EventPlayer(), Hero.Zenyatta);
    SetMoveSpeed(EventPlayer(), 300);
}

rule: "Player: Interact (Report Corpse)"
Event.OngoingPlayer
if (gameState == GameState.Play)
if (playing)
if (IsButtonHeld(EventPlayer(), Button.Reload))
if (EventPlayer().isAlive)
if (EventPlayer().canReportCorpse)
{
    Corpse corpse = EventPlayer().closestCorpse;
    EventPlayer().canReportCorpse = false;
    CreateEffect(
        VisibleTo : AllPlayers(),
        Type      : Effect.EnergySound,
        Color     : Color.Purple,
        Position  : corpse.Position,
        Radius    : 5,
        Reevaluation: EffectRev.None
    );
    ModifyVariable(corpses, Operation.RemoveFromArrayByValue, corpse);
    DestroyEffect(corpse.EntityId);
    DestroyInWorldText(corpse.TextId);

    StartVotingRound();
}
